---
title: "Preventing SQL Injection in Shiny Applications"
author: "Matthew Sharkey"
date: "March 15, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Injection Attacks are Child's Play

The Open Web Aplication Security Project (OWASP) publishes the Top 10 Most Critical Web Application Security Risk.  The list is a good starting point for developers seeking to improve web-app security.  Injection based attacks have held the number one spot since 2010.

Why is injection at the top?  Hackers can discover vulenrable sites with little effort.  Automated tools like Havij and search engines like Shodan make injection attacks child's play, ![literally](https://techcrunch.com/2018/08/12/hacking-the-websites-responsible-for-election-information-is-so-easy-an-11-year-old-did-it/).  The potential impact from injection based attacks, espcially SQL injection, is sevre.  SQL injection vulenrabilities allow hackers to circumvent controls and run arbituray scripts against the database.  These scripts might steal data, destroy data, create a backdoor or all the above.  Despite the ease and severity organizations still have trouble eliminating the threat.  The news article featured in the GIF below were all written in the last two years.  They are just a few examples of SQL injection that I found interesting. 

<center>
![](D:/sqlinjection.gif)
</center>

If large  organizations like Cisco, Instagram, Lenevo, and Texas.Gov are susectable then I'm certain my code is susceptable.  MySQL and Postgres write source code for RDBMs and yet they recently had a SQL injection vulenrability as well.  As long as developers use dynamic code with user input the risk for injection will not disappear.

###  Attacking a Shiny App

I'll illustrate an injection attack using a sample Shiny App.  The app takes an email address and job title as inputs and saves them to a SQL Server database.  There are several vulenrabilities to the app in it's current state.






Untrusted data, data that comes from users, vs trusted data, our code


Defense techniques:
White list known inputs,don't be to restrive of the characterset.  Some characters are legit e.g. Lee's Summit.  Don't use a blacklist, it's hard to predict what will be.  Data need to conform to patterns or certain character sets.

Query Parameterization.  Seperate the data from being able to being able to manipulate query logic. Keep query data seperate from the user input data.

* Query can't be changed at run time.


Stored Procedure defense

Server Side Defense
  -Principle of least privelage,only grant execute to stored procs.

Network Isolation, Only alow connections through the web app.

Use IDS, Intrustion Dection System, WAF like baricuda, CloudFlare

Keep Database and Webservers patched.

-Hash and Salt Sensitve Values, If you never need to reference the source system directly why do you need to maintain the original values?  For example passwords.   store passwords in plain text.








--Limit  Account Web Account privelages

```{r cars}
summary(cars)
```