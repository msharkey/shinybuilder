---
title: "Preventing SQL Injection in Shiny Applications"
author: "Matthew Sharkey"
date: "March 15, 2019"
output: html_document
---

```{r setup, include=FALSE}
library(DBI)
knitr::opts_chunk$set(echo = TRUE)
myDriver <- 'SQL Server'
# Use . for a local connection, otherwise specify Server Machine Name or IP address
myServer <- '.\\snapman'
myDatabase <- 'Cab_Demo'


trusted_connection <- dbConnect(odbc::odbc(),Driver= myDriver,Server = myServer
                                ,Database = myDatabase,Trusted_Connection='yes')

```

### Injection Attacks are Child's Play

The Open Web Aplication Security Project (OWASP) publishes the Top 10 Most Critical Web Application Security Risk.  The list is a good starting point for developers seeking to improve web-app security.  Injection based attacks have held the number one spot since 2010.

Why is injection at the top?  Hackers can discover vulenrable sites with little effort.  Automated tools like Havij and search engines like Shodan make injection attacks child's play, ![literally](https://techcrunch.com/2018/08/12/hacking-the-websites-responsible-for-election-information-is-so-easy-an-11-year-old-did-it/).  The potential impact from injection based attacks, espcially SQL injection, is sevre.  SQL injection vulenrabilities allow hackers to circumvent controls and run arbituray scripts against the database.  These scripts might steal data, destroy data, create a backdoor or all the above.  Despite the ease and severity organizations still have trouble eliminating the threat.  The news article featured in the GIF below were all written in the last two years.  They are just a few examples of SQL injection that I found interesting. 

<center>
<!--![](D:/sqlinjection.gif)-->
</center>

If large  organizations like Cisco, Instagram, Lenevo, and Texas.Gov are susectable then I'm certain my code is susceptable.  MySQL and Postgres write source code for RDBMs and yet they recently had a SQL injection vulenrability as well.  As long as developers use dynamic code with user input the risk for injection will not disappear.

###  Breaking Down a Shiny App

I'll illustrate an injection attack using a sample Shiny App. (Delete Previous Sentenance)  Before I can illustrate an injection attack I'll first need to go over some SQL fundamentals.  The app takes an email address and job title as inputs and saves them to a SQL Server databases.  Users can also update and delete existing records.  The app persists user input in one table named dbo.Persons.  This script creates the dbo.Persons table and then inserts one row consiting of an email adress and job title.  The last statement selects the newly inserted row.



```{sql checkoutthecons, eval=TRUE,connection = trusted_connection}
SET NOCOUNT ON;
DROP TABLE IF EXISTS dbo.Persons;
CREATE TABLE dbo.Persons (
  email Varchar(100) PRIMARY KEY, 
  jobtitle Varchar(100)
);

INSERT INTO dbo.Persons VALUES ('q1724449@nwytg.net','Analyst');

SELECT email, jobtitle FROM dbo.Persons;

```

Using Shiny UI controls the user essentially has the ability to execute these queries against the database.


```{sql checkouttheconsr, eval=FALSE,connection = trusted_connection}

-- Select all rows from the dbo.Persons table
SELECT * FROM dbo.Persons

--Get the jobtitle where the email address matches the user provided email
SELECT jobtitle FROM dbo.Persons WHERE email = 'User Input'

--Update the Email and job title where the email address matches the user provided email
UPDATE dbo.Persons SET Email = 'User Input',jobtitle=  'User Input' WHERE email ='User Input')

--Delete a row where the email matches the user provided email
DELETE FROM dbo.Persons WHERE Email = 'User Input'

--add a new row to the dbo.Persons table based on user provided email and jobtitle
INSERT INTO dbo.Persons(email,jobtitle) VALUES ('User Input','User Input')

```

The SELECT, UPDATE, DELETE, and INSERT commands are the fundemental operations of data modification language (DML).  The other types of operations are data control language (DCL) and data definition language (DDL).  The CREATE TABLE query above is an example of DDL.  DCL is commonly executed outside the application during the development phase or by a System Admin during deployment.  The example email app is typical of most app in that it only executes DML.  I'll intergrate the DML queries into the app by dynamically building the query string with the values of user input.


```{r badqueries, eval=FALSE}
    jt <- dbGetQuery(myPool,
                     paste0("Select jobtitle From dbo.Persons Where email   ='",input$titled,"'"))

          dbGetQuery(myPool,
                     paste0("UPDATE dbo.Persons SET Email = '",input$emailupdate,"',jobtitle=  '",input$titleupdate,"'
                             Where email ='",input$titled,"'"))
          
          dbGetQuery(myPool,
                     paste0("DELETE From dbo.Persons WHERE Email = '",input$titled,"'"))
          
          dbGetQuery(myPool
                     ,paste0("Insert into dbo.Persons values ('",input$email,"','",input$title,"')"))
```


There is nothing stoping a user from passing a SQL script to either one of the inputs.  The giff below first shows how a user a suppose to interact with the app.  Then it shows how a hacker can pass a malicus script through the email input field.


<center>
<!--![](D:/shinybuilderInjection.gif)-->
</center>


I set a breakpoint after the user clicks save and before the query appends the the row to the table.  The string executed against the database is two seperate SQL commands. The second command truncates the Persons table.  In a real world production system this might be data loss (if there're no backups) or application downtime.

```{r chrum}

email <- "'','') TRUNCATE TABLE dbo.Persons --"
title <- "Analyst"
paste0("Insert into dbo.Persons values ('",email,"','",title,"')")


```

###  Defending Against Injection

I mix trusted data with untrusted data and for that my app is vulenrable.  The trusted data is the app and query code.  The untrusted data is user input.  I can start to seperate the trusted and unstrusted data through parametrised queries.  Instead of passing the user input variables directly to the query string, I instead store the user variables into parameters.  I then reference the parameters in the query instead of the user variables directly.

```{r chrum2,eval=FALSE}

  query <- sqlInterpolate(con,"Insert into dbo.Persons values (?email,?title)",input$email,input$title))

  dbGetQuery(myPool, query)

```





There are several vulenrabilities to the app in it's current state.






Untrusted data, data that comes from users, vs trusted data, our code


Defense techniques:
White list known inputs,don't be to restrive of the characterset.  Some characters are legit e.g. Lee's Summit.  Don't use a blacklist, it's hard to predict what will be.  Data need to conform to patterns or certain character sets.

Query Parameterization.  Seperate the data from being able to being able to manipulate query logic. Keep query data seperate from the user input data.

* Query can't be changed at run time.


Stored Procedure defense

Server Side Defense
  -Principle of least privelage,only grant execute to stored procs.

Network Isolation, Only alow connections through the web app.

Use IDS, Intrustion Dection System, WAF like baricuda, CloudFlare

Keep Database and Webservers patched.

-Hash and Salt Sensitve Values, If you never need to reference the source system directly why do you need to maintain the original values?  For example passwords.   store passwords in plain text.



--Limit  Account Web Account privelages
