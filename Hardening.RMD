---
title: "Preventing SQL Injection in Shiny Applications"
author: "Matthew Sharkey"
date: "March 15, 2019"
output: html_document
---

```{r setup, include=FALSE}
library(DBI)
knitr::opts_chunk$set(echo = TRUE)
myDriver <- 'SQL Server'
# Use . for a local connection, otherwise specify Server Machine Name or IP address
myServer <- './/snapman'
myDatabase <- 'Cab_Demo'


trusted_connection <- dbConnect(odbc::odbc(),Driver= myDriver,Server = myServer
                                ,Database = myDatabase,Trusted_Connection='yes')

```

### Injection Attacks = Child's Play

The Open Web Application Security Project (OWASP) publishes the Top 10 Most Critical Web Application Security Risk.  The list guides developers seeking to improve web-app security.  Injection based attacks have held the number one spot since 2010.

Why is injection at the top?  For one, Hackers discover vulnerable sites with little effort.  Tools like Havij and Shodan make injection attacks ![child's play]. (https://techcrunch.com/2018/08/12/hacking-the-websites-responsible-for-election-information-is-so-easy-an-11-year-old-did-it/).  The potential impact from injection based attacks, especially SQL injection, is severe.  SQL injection vulnerabilities allow hackers to circumvent security controls. and run arbitrary scripts against the database.  These scripts might steal data, destroy data, create a backdoor or all the above.  Despite the ease and severity organizations still have trouble eliminating the threat.  The news article featured in the GIF below were all written in the last two years.  They are a few examples of SQL injection that I found interesting. 

<center>
<!---->
![](D:/sqlinjection.gif)
</center>

Large organizations like Cisco, Instagram and Texas.Gov still find injection vulnerabilities.   MySQL and PostgreSQL write source code for database systems but even they are not immune.  If these companies write vulnerable code then I'm capable writing vulnerable code.  Baring a major a coding paradigm shift, the risk for injection will not disappear.

###  Breaking Down a Shiny App

The goal of this post is to show how to defend a Shiny app from SQL injection.  I built a simple shiny app to illustrate.  The app takes an email address and job title as inputs and saves them to a SQL Server database.  Users can also update and delete existing records.  The app persists user input in one table named dbo.Persons.  The following SQL creates dbo.Persons and then inserts one row.  The last statement selects all the rows.

```{sql checkoutthecons, eval=TRUE,connection = trusted_connection}
SET NOCOUNT ON;
DROP TABLE IF EXISTS dbo.Persons;
CREATE TABLE dbo.Persons (
  email Varchar(100) PRIMARY KEY, 
  jobtitle Varchar(100)
);

INSERT INTO dbo.Persons VALUES ('q1724449@nwytg.net','Analyst');

SELECT email, jobtitle FROM dbo.Persons;

```

The shiny UI controls provide input to the following queries.  R combines the user input and query code.


```{sql checkouttheconsr, eval=FALSE,connection = trusted_connection}

-- Select all rows from the dbo.Persons table
SELECT * FROM dbo.Persons

--Get the jobtitle where the email address matches the user provided email
SELECT jobtitle FROM dbo.Persons WHERE email = 'User Input'

--Update the Email and job title where the email address matches the user provided email
UPDATE dbo.Persons SET Email = 'User Input',jobtitle=  'User Input' WHERE email ='User Input')

--Delete a row where the email matches the user provided email
DELETE FROM dbo.Persons WHERE Email = 'User Input'

--add a new row to the dbo.Persons table based on user provided email and jobtitle
INSERT INTO dbo.Persons(email,jobtitle) VALUES ('User Input','User Input')

```

SELECT, UPDATE, DELETE, and INSERT are the fundamental operations of data modification language (DML).  My sample app only executes DML code.  The other types of query code are data control language (DCL) and data definition language (DDL).  I don't see a lot of apps using DCL and DDL but there're times when it's appropriate.  The CREATE TABLE query above is an example of DDL.  The code below concatenates the user input with query code and the execute the statement.


```{r badqueries, eval=FALSE}
    jt <- dbGetQuery(myPool,
                     paste0("Select jobtitle From dbo.Persons Where email   ='",input$titled,"'"))

          dbGetQuery(myPool,
                     paste0("UPDATE dbo.Persons SET Email = '",input$emailupdate,"',jobtitle=  '",input$titleupdate,"'
                             Where email ='",input$titled,"'"))
          
          dbGetQuery(myPool,
                     paste0("DELETE From dbo.Persons WHERE Email = '",input$titled,"'"))
          
          dbGetQuery(myPool
                     ,paste0("Insert into dbo.Persons values ('",input$email,"','",input$title,"')"))
```
The code is vulnerable to SQL injection.  There is nothing stopping a user from passing a SQL script to either one of the inputs.  The GIF below first shows how a user a suppose to interact with the app.  Then it shows how a hacker can pass a malicious script through the email input field.


<center>
<!---->
![](D:/shinybuilderInjection.gif)
</center>


The string executed against the database is two separate SQL commands. The second command truncates the Persons table.  In a real world production system this might be data loss or application downtime.

```{r chrum}

email <- "'','') TRUNCATE TABLE dbo.Persons --"
title <- "Analyst"
paste0("Insert into dbo.Persons values ('",email,"','",title,"')")


```

###  Defending Against Injection

#### Paramertization and String Escaping

The app mixes trusted data with untrusted data.  The trusted data is the app and query code.  The untrusted data is user input.  If untrusted data mixes with trusted data then query code becomes changeable at run time.  I can start to separate the trusted and untrusted data through parameterised queries.  Instead of passing the user input variables to the query string, I  store them in parameters.  Then I reference the parameters  instead of the user variables.

```{r chrum2,eval=FALSE}

  query <- sqlInterpolate(con,"Insert into dbo.Persons values (?email,?title)",input$email,input$title))

  dbGetQuery(myPool, query)

```


Using sqlInterpolate helps isolate the user input from the query string.  Now single tick marks are escaped making it more difficult to execute an ad-hoc script.  I attempted the same injection attack as before.  This time the input was handled as single text string.

![](C:/Users/mshar/OneDrive/Documents/R_UG_Demo/parameterized.png)

#### Whitelist input

The app should only allow valid characters as input.  For example, if user attempts to pass a string with spaces in the email field then the app should prevent the input from entering the database.  I implemented a email whitelist by comparing the input with a Regex pattern.


```{r chrum3,eval=FALSE}

emailwhitelist <- "^[[:alnum:].-_]+@[[:alnum:].-]+$"

   if(!is.na(str_match(input$email, emailwhitelist))){
    query <- sqlInterpolate(con,
                            "INSERT INTO dbo.Persons 
                            VALUES(?email,?title)",input$email,input$title))
  dbGetQuery(myPool, query)
     } else {stop("Not a valid email.")}


```

Developers should use a whitelist technique with caution.  Using a restrictive character set could block legitimate input.  For example, the Regex pattern above blocks email addressed with a single quote.  Are quotes possible in emails?  If they aren't allowed by some email providers will that change in the future?  It's possible.  If implementing a whitelist it may be wise to store the input pattern in a table.  If the whitelist pattern changes then the pattern can be changed on the backend without changing app code.

#### Server Side Defense

The database user account should have the minimal permissions needed.  I would have not been able to truncate the table in the example above had I only had permission to SELECT and INSERT.  If I need to fine tune permissions then I wrap all database commands into stored procedures and then grant execute permission to the stored procedures.  Now the user can only has permission to interact with the database in a structured fashion.  For example, instead of  hard coding the INSERT query in my app code I can instead wrap the INSERT into a stored procedure on the backend.

```{sql storedproc, eval = FALSE,connection = trusted_connection}
Use Cab_Demo
GO

DROP PROCEDURE IF EXISTS dbo.uspInsertEmail;
GO
CREATE PROCEDURE dbo.uspInsertEmail
@email Varchar(100),
@title Varchar(100)
AS
INSERT INTO dbo.Persons
VALUES (@email,@title)

GO

GRANT EXECUTE ON dbo.uspInsertEmail TO shinybuilder_app 

```


The stored procedure provides an interface between the table and the application.

```{r finalR , eval=FALSE}
  query <- sqlInterpolate(con
                          ,"EXECUTE dbo.uspInsertEmail ?email,?title",input$email,input$title))

  dbGetQuery(myPool, query)

```


A few lines of defense exist outside of the app and database server.  An intrusion detection system (IDS) uses signatures to detect potential attacks.  Some IDS also provide real time alerting features.

Finally, make sure all technologies involved in the application are patched.  This includes the database server, the web server, the individual packages and any other systems interacting with the application.  In an ideal world, software vendors issue patches after immediately after discovering an injection vulnerability.


